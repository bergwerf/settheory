(* A proof that the continuum hypothesis holds for closed sets. *)

From set_theory Require Import lib fn pair bin set d cb.

Require Import Inverse_Image.
Require Import List.
Import ListNotations.

(*
First we will see that it is possible to embed the Cantor space into any
non-empty, perfect subset of the Cantor space (this generalizes to other
topologies such as the real numbers).
*)
Section Perfect_embedding.

Variable X : P C.
Hypothesis nonempty_X : X ≠ ∅.
Hypothesis closed_X : Closed X.
Hypothesis perfect_X : Perfect X.

(* The set X ⊆ C embeds C if a one-to-one function f : C -> X exists. *)
Definition EmbedsC := ∃f : C -> C, (∀α, X (f α)) /\ Injective f.

(*
The first approach I thought of is using an inductive predicate to represent
prefix embeddings. The main problem with the prefix embedding predicate
presented below is that it is not canonical. A possible solution is to require
that each split is the first such split (any smaller prefix does not split). We
then need AC to convert this predicate into a prefix-choosing function. Because
I got quite stuck proving properties about this predicate I decided to try
another method that is entirely constructive.
*)
Section Embedding_predicate.

(*
We define an inductive predicate which determines a valid prefix in X to map any
given prefix in C to. A construction of [prefix_embedding (m, α) (n, β)] means
that the prefix (m, α) embeds into X using the prefix (n, β). The constrution
still allows many different prefix embeddings, so additional requirements are
needed to obtain a canonical embedding.
*)
Inductive prefix_embedding : nat * C -> nat * C -> Prop :=
  (* We inductively search for divisions, so β must be an element of X. *)
  | prefix_embedding_0 : ∀α β, X β -> prefix_embedding (0, α) (0, β)
  (* To add one boolean to the prefix, we have to look for a division in X. *)
  | prefix_embedding_S : ∀m α n β k γ γ',
    (* γ, γ' ∈ X *)
    X γ -> X γ' ->
    (* γ and γ' belong to the (n + k)-th branch of β. *)
    Branch (n + k) β γ -> Branch (n + k) β γ' ->
    (* γ and γ' part at n + k, and γ goes in the direction of α at m. *)
    γ (n + k) ≠ γ' (n + k) -> γ (n + k) = α m ->
    (* (n, β) is a prefix embedding of (m, α). *)
    prefix_embedding (m, α) (n, β) ->
    (* Then (n + k, γ) is a prefix embedding of (1 + m, α). *)
    prefix_embedding (S m, α) (n + k, γ).

(* Every embedding is in X. *)
Lemma prefix_embedding_in_X m α n β : prefix_embedding (m, α) (n, β) -> X β.
Proof. intros H; now inversion H. Qed.

(* Every prefix can be embedded. *)
Lemma prefix_embedding_ex :
  ∀s_dom, ∃s_img, prefix_embedding s_dom s_img.
Proof.
intros [m α]; induction m.
- apply not_empty in nonempty_X as [β Hβ]; exists (0, β).
  now apply prefix_embedding_0.
- destruct IHm as [[n β] H1β]. apply prefix_embedding_in_X in H1β as H2β.
  (* Find a second element in Branch n β, and find where it splits from β. *)
  apply perfect_X in H2β as H3β. destruct (H3β n) as [γ [H1γ [H2γ H3γ]]].
  apply C_neq in H1γ as [i H1γ];
  apply neq_least_shared_branch in H1γ as [k [H1k H2k]].
  assert(H1n : n <= k). { apply not_gt; intros H. now apply H3γ in H. }
  assert(H2n : n + (k - n) = k) by lia.
  (* Choose between β and γ based on α(m). *)
  destruct (bool_dec (α m) (β k)).
  + exists ((n + (k - n)), β); apply prefix_embedding_S
    with (β:=β)(γ:=β)(γ':=γ); rewrite ?H2n; try easy.
  + exists ((n + (k - n)), γ); apply prefix_embedding_S
    with (β:=β)(γ:=γ)(γ':=β); rewrite ?H2n; try easy.
    now apply not_eq_sym. now destruct (α m), (β k), (γ k).
Qed.

End Embedding_predicate.

(*
An idea from intuitionism that is quite useful here is to consider X as a law σ
that accepts or rejects prefixes (a finitary spread). Given such a law we can
construct prefixes in σ for any α : C, and then prove its correctness
constructively. Later we use AC to obtain such a σ for X.
*)
Section Finitary_spread.

(* Spread law. *)
Variable σ : list bool -> bool.

(* σ is inhabited. *)
Hypothesis σ_law0 : σ [] = true.

(* A prefix is accepted iff a continuation is accepted. *)
Hypothesis σ_law1 : ∀s, σ s = true <->
  σ (false :: s) = true \/ σ (true :: s) = true.

(* Every prefix has two different continuations (eventually splits). *)
Hypothesis σ_split : ∀s, σ s = true ->
  ∃t, σ (false :: t ++ s) = true /\ σ (true :: t ++ s) = true.

(*
Inbedding of C generated by σ.
s := current prefix in σ
α := input sequence in C
n := prefix to be generated in α
*)
Fixpoint Cσ s α n :=
  match n with
  | 0 => s
  | S m =>
  (* Check which continuations are accepted. *)
  let ex0 := σ (false :: s) in
  let ex1 := σ (true :: s) in
  (* If two continuations are possible, then follow α. *)
  if ex0 && ex1
  then Cσ (α 0 :: s) (1<<α) m
  else Cσ (ex1 :: s) α m
  end.

Lemma σ_restrict b s : σ (b :: s) = true -> σ s = true.
Proof. intros; apply σ_law1. destruct b; auto. Qed.

Lemma σ_restrict_app s t : σ (s ++ t) = true -> σ t = true.
Proof. induction s; simpl; intros. easy. eapply IHs, σ_restrict, H. Qed.

Lemma Cσ_accepted s α n :
  σ s = true -> σ (Cσ s α n) = true.
Proof.
revert s α; induction n; simpl; intros. easy.
destruct (σ (false :: s)) eqn:b1, (σ (true :: s)) eqn:b2;
simpl; apply IHn. now destruct (α 0). easy. easy. exfalso.
apply σ_law1 in H as [H|H]. now rewrite H in b1. now rewrite H in b2.
Qed.

Lemma length_removelast {T} (l : list T) :
  l ≠ [] -> length (removelast l) < length l.
Proof.
induction l. easy. destruct l; simpl in *; intros. apply lt_0_1.
apply succ_lt_mono with (m:=S (length l)). now apply IHl.
Qed.

Notation "b ⊕ c" := (xorb b c) (at level 20).
Lemma xorb_andb b c : b ⊕ c = true -> b && c = false.
Proof. now destruct b, c. Qed.

Lemma Cσ_split s α :
  σ s = true -> ∃n,
  (∀m, m < n -> σ (false :: Cσ s α m) ⊕ σ (true :: Cσ s α m) = true) /\
  σ (false :: Cσ s α n) && σ (true :: Cσ s α n) = true.
Proof.
(* Well-founded induction using the split given by the hypothesis. *)
intros H; assert(Hs := H); apply σ_split in H as [t [H1t H2t]].
revert Hs H1t H2t; revert s; induction t using (well_founded_induction
  (wf_inverse_image _ nat _ (@length _) lt_wf_0)); intros.
(* Trivial case: t0 = []. *)
destruct (list_eq_dec bool_dec t0 []) as [Ht0|Ht0].
subst; rewrite app_nil_l in *. exists 0; split.
easy. simpl; now rewrite H1t, H2t.
(* Determine if σ does not yet split at 0. *)
destruct (σ (false :: Cσ s α 0) ⊕ σ (true :: Cσ s α 0)) eqn:H0.
- (* If not, then recurse on a shorter sublist. *)
  pose(t' := removelast t0); pose(tn := last t0 false).
  assert(R : t0 ++ s = t' ++ tn :: s). {
    rewrite <-(app_nil_l s) at 2; rewrite app_comm_cons, app_assoc.
    replace t0 with (t' ++ [tn]). easy.
    symmetry; now apply app_removelast_last. }
  rewrite R in *; clear R.
  assert(Hs' : σ (tn :: s) = true). {
    rewrite app_comm_cons in H1t; now apply σ_restrict_app in H1t. }
  (* Using H0 we can prove a useful identity. *)
  assert(∀i, Cσ (tn :: s) α i = Cσ s α (S i)). {
    intros; simpl; simpl in H0. apply xorb_andb in H0; rewrite H0.
    replace tn with (σ (true :: s)). easy. destruct tn.
    easy. rewrite Hs' in H0; now simpl in H0. }
  (* Apply induction hypothesis. *)
  assert(length t' < length t0) by now (apply length_removelast).
  apply H with (s:=tn :: s) in H2 as [n [H1n H2n]]; try easy.
  exists (S n); split.
  (* Finish. *)
  intros; destruct m. easy. apply succ_lt_mono in H2; apply H1n in H2.
  now rewrite <-H1. now rewrite <-H1.
- (* Otherwise the split is again at 0. *)
  exists 0; split. easy. revert H0.
  destruct (σ (false :: Cσ s α 0)) eqn:b0, (σ (true :: Cσ s α 0)) eqn:b1;
  simpl; try easy. exfalso; simpl in *. apply σ_law1 in Hs.
  destruct Hs. now rewrite H0 in b0. now rewrite H0 in b1.
Qed.

Lemma Cσ_inj s α1 α2 i :
  σ s = true -> α1 i ≠ α2 i -> ∃n, Cσ s α1 n ≠ Cσ s α2 n.
Proof.
revert s α1 α2; induction i; intros.
- (* α1 and α2 are apart at the next split. *)
  admit.
- (* go to the next split, and apply induction hypothesis. *)
  assert((1<<α1) i ≠ (1<<α2) i) by easy; eapply IHi in H1 as [n Hn].
  (* Cσ s α n = Cσ (Cσ s α n2 ++ s) (1<<α) n1 ++ Cσ s α n2 *)
Abort.

End Finitary_spread.

(* Obtain a law for X using AC, and use the above construction. *)
Theorem nonempty_closed_perfect_embeds_C :
  EmbedsC.
Proof.
Admitted.

End Perfect_embedding.

(*
We can now prove the continuum hypothesis (CH) for closed sets. With closed sets
we can exploit a hierarchy of derived sets given by the Cantor-Bendixon
derivatives. Open sets are trickier because a countable open set may contain
uncountably many limit points. (Take for example all finite sequences prepended
to zeros. This is similar to the rational numbers which approach all real
numbers.)
*)
Section Continuum_hypothesis.

(* Every infinite set X is either countable or embeds C. *)
Definition CH X := Infinite X -> Countable X \/ EmbedsC X.

(* CH holds for closed sets. *)
Theorem closed_continuum_hypothesis X :
  Closed X -> CH X.
Proof.
destruct (classic (K X = ∅)).
- left. rewrite <-diff_empty, <-H. now apply CB_countable_diff, CB_K.
- right. apply nonempty_closed_perfect_embeds_C in H as [f [H1f H2f]].
  exists f; split. intros; eapply CB_incl. easy. now apply CB_K.
  easy. easy. apply CB_closed with (X:=X). easy. now apply CB_K.
  now apply CB_K_perfect.
Qed.

End Continuum_hypothesis.
