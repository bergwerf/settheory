(* A proof that the continuum hypothesis holds for closed sets. *)

From set_theory Require Import lib fn pair bin set d cb.

Require Import List.
Import ListNotations.

(*
First we will see that it is possible to embed the Cantor space into any
non-empty, perfect subset of the Cantor space (this generalizes to other
topologies such as the real numbers).
*)
Section Perfect_embedding.

Variable X : P C.
Hypothesis nonempty_X : X ≠ ∅.
Hypothesis closed_X : Closed X.
Hypothesis perfect_X : Perfect X.

(* The set X ⊆ C embeds C if a one-to-one function f : C -> X exists. *)
Definition EmbedsC := ∃f : C -> C, (∀α, X (f α)) /\ Injective f.

(*
An idea from intuitionism that is quite useful here is to consider X as a law σ
that accepts or rejects prefixes. Given such a law we can construct prefixes in
σ for any α : C, and then prove its correctness constructively. Later we use AC
to obtain such a σ for X.
*)
Section Finitary_spread.

Notation "b ⊕ c" := (xorb b c) (at level 20).

(* Spread law. *)
Variable σ : list bool -> bool.

Definition σ_1way s := σ (false :: s) ⊕ σ (true :: s).
Definition σ_2way s := σ (false :: s) && σ (true :: s).

(* A prefix is accepted iff a continuation is accepted. *)
Hypothesis σ_cont : ∀s, σ s = true <->
  σ (false :: s) = true \/ σ (true :: s) = true.

(* Every prefix has two different continuations (eventually splits). *)
Hypothesis σ_split : ∀s, σ s = true -> ∃t, σ_2way (t ++ s) = true.

(*
Inbedding of C generated by σ.
s := current prefix in σ
α := input sequence in C
n := prefix to be generated in α
*)
Fixpoint Cσ s α n :=
  match n with
  | 0 => s
  | S m =>
  if σ_2way s
  then Cσ (α 0 :: s) (1<<α) m
  else Cσ (σ (true :: s) :: s) α m
  end.

Definition Cσ_track s α n := ∀m, m < n -> σ_1way (Cσ s α m) = true.

Lemma xorb_split b c : b ⊕ c = true -> b = true \/ c = true.
Proof. destruct b, c; auto. Qed.

Lemma xorb_l b c : b ⊕ c = true -> b = true <-> c = false.
Proof. now destruct b, c. Qed.

Lemma σ_cons b s : σ (b :: s) = true -> σ s = true.
Proof. intros; apply σ_cont. destruct b; auto. Qed.

Lemma σ_app s t : σ (s ++ t) = true -> σ t = true.
Proof. induction s; simpl; intros. easy. eapply IHs, σ_cons, H. Qed.

Lemma σ_1way_inv s : σ_1way s = true -> σ s = true.
Proof. intros H; apply xorb_split in H as [H|H]; eapply σ_cons, H. Qed.

Lemma σ_2way_cons s b : σ_2way s = true -> σ (b :: s) = true.
Proof. unfold σ_2way; intros; b_Prop; now destruct b. Qed.

Lemma σ_2way_inv s : σ_2way s = true -> σ s = true.
Proof. intros; eapply σ_cons with (b:=false), σ_2way_cons, H. Qed.

Lemma σ_1way_cons a s :
  σ_1way s = true -> σ (a :: s) = true -> σ (true :: s) = a.
Proof.
intros; destruct a. easy.
eapply xorb_l. apply H. easy.
Qed.

Lemma σ_12way s :
  σ s = true -> σ_1way s ⊕ σ_2way s = true.
Proof.
unfold σ_1way, σ_2way.
destruct (σ (false :: s)) eqn:F, (σ (true :: s)) eqn:T; try easy.
intros H; exfalso. apply σ_cont in H as [H|H].
now rewrite F in H. now rewrite T in H.
Qed.

Lemma σ_cons_true s :
  σ s = true -> σ (σ (true :: s) :: s) = true.
Proof.
intros; destruct (σ (true :: s)) eqn:E. easy.
eapply xorb_l. eapply xorb_l. apply σ_12way.
easy. unfold σ_2way; now rewrite E, andb_false_r. easy.
Qed.

Lemma Cσ_accepted s α n :
  σ s = true -> σ (Cσ s α n) = true.
Proof.
revert s α; induction n; simpl; intros. easy.
destruct (σ_2way s) eqn:T; simpl; apply IHn.
now apply σ_2way_cons. now apply σ_cons_true.
Qed.

Lemma Cσ_S s α n :
  σ_1way s = true -> Cσ s α (S n) = Cσ (σ (true :: s) :: s) α n.
Proof.
intros; simpl. replace (σ_2way s) with false. easy.
symmetry; eapply xorb_l. apply σ_12way. apply σ_1way_inv, H. easy.
Qed.

Lemma Cσ_split s α :
  σ s = true -> ∃n, Cσ_track s α n /\ σ_2way (Cσ s α n) = true.
Proof.
intros H; assert(Hs := H); apply σ_split in H as [t Ht].
(* By doing induction over [rev t] we essentially do a linear search. *)
rewrite <-(rev_involutive t) in Ht; remember (rev t) as s'; clear Heqs' t.
revert Ht Hs; revert s; induction s'; simpl; intros. now exists 0.
(* General observations *)
rewrite <-app_assoc in Ht.
assert(σ (a :: s) = true) by (eapply σ_app, σ_2way_inv, Ht).
(* Either σ splits at a :: s, or we can use the induction hypothesis. *)
destruct (σ_2way s) eqn:E. now exists 0.
destruct (IHs' _ Ht) as [n [H1n H2n]]. easy. simpl in H1n, H2n.
assert(H0 : σ_1way s = true). { eapply xorb_l. apply σ_12way; easy. easy. }
exists (S n); split.
- intros m Hm; destruct m. simpl. easy.
  apply succ_lt_mono in Hm; apply H1n in Hm.
  erewrite Cσ_S. erewrite σ_1way_cons. apply Hm. all: easy.
- erewrite Cσ_S. erewrite σ_1way_cons. apply H2n. all: easy.
Qed.

Lemma Cσ_change_seq s α α1 α2 n :
  Cσ_track s α n -> Cσ s α1 n = Cσ s α2 n.
Proof.
revert s α α1 α2; induction n; intros. easy.
assert(σ_1way s = true). { replace s with (Cσ s α 0) by easy. apply H. lia. }
erewrite ?Cσ_S; try easy. eapply IHn; intros m Hm.
rewrite <-Cσ_S. apply H. lia. easy.
Qed.

Lemma Cσ_add s α α' m n :
  Cσ_track s α m -> Cσ s α' (m + n) = Cσ (Cσ s α' m) α' n.
Proof.
revert s; induction m; intros. easy.
assert(σ_1way s = true) by (apply (H 0); lia).
rewrite add_succ_l, Cσ_S. rewrite IHm, <-Cσ_S. easy.
easy. intros i Hi; rewrite <-Cσ_S. apply H; lia. all: easy.
Qed.

Lemma Cσ_inj s α1 α2 i :
  σ s = true -> α1 i ≠ α2 i -> ∃n, Cσ s α1 n ≠ Cσ s α2 n.
Proof.
intros Hs Hi; apply neq_least_shared_branch in Hi as [j [H1j H2j]].
clear i; revert Hs H1j H2j; revert s α1 α2; induction j; intros.
- (* α1 and α2 are apart at the next split. *)
  apply Cσ_split with (α:=α1) in Hs as [n [H1n H2n]]; exists (n + 1).
  erewrite ?Cσ_add, Cσ_change_seq with (n:=n)(α1:=α2)(α2:=α1).
  simpl; rewrite ?H2n. intros H0; apply H2j. now injection H0.
  all: apply H1n.
- (* go to the next split and apply induction hypothesis. *)
  apply Cσ_split with (α:=α1) in Hs as [m [H1m H2m]].
  assert((1<<α1) j ≠ (1<<α2) j) by easy.
  eapply IHj in H as [n Hn]. exists (m + S n).
  erewrite ?Cσ_add, Cσ_change_seq with (n:=m)(α1:=α2)(α2:=α1).
  simpl; rewrite ?H2m. rewrite <-H1j. apply Hn. lia.
  1-3: apply H1m. unfold σ_2way in H2m; b_Prop.
  now destruct (α1 0). now apply Branch_del.
Qed.

End Finitary_spread.

(* Obtain a law for X using AC, and use the above construction. *)
Theorem nonempty_closed_perfect_embeds_C :
  EmbedsC.
Proof.
Admitted.

End Perfect_embedding.

(*
We can now prove the continuum hypothesis (CH) for closed sets. With closed sets
we can exploit a hierarchy of derived sets given by the Cantor-Bendixon
derivatives. Open sets are trickier because a countable open set may contain
uncountably many limit points. (Take for example all finite sequences prepended
to zeros. This is similar to the rational numbers which approach all real
numbers.)
*)
Section Continuum_hypothesis.

(* Every infinite set X is either countable or embeds C. *)
Definition CH X := Infinite X -> Countable X \/ EmbedsC X.

(* CH holds for closed sets. *)
Theorem closed_continuum_hypothesis X :
  Closed X -> CH X.
Proof.
destruct (classic (K X = ∅)).
- left. rewrite <-diff_empty, <-H. now apply CB_countable_diff, CB_K.
- right. apply nonempty_closed_perfect_embeds_C in H as [f [H1f H2f]].
  exists f; split. intros; eapply CB_incl. easy. now apply CB_K.
  easy. easy. apply CB_closed with (X:=X). easy. now apply CB_K.
  now apply CB_K_perfect.
Qed.

End Continuum_hypothesis.
